from config.config import Config
from helpers.utils import load_report, clean_report, convert_to_string
from models.TransformerModel import TransformerModel
from classifiers.SVC import SVCModel
from classifiers.XGBoost import XGBoostModel
from models.TfidfModel import TfidfModel
from models.Doc2VecCombinator import Doc2VecCombinator
import argparse
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class Predictor:
    def __init__(self):
        self.report_path = '/Users/filipibl/PycharmProjects/detector/report.json'
        self.embedding = 'distilbert'
        self.classifier_name = 'xgboost'
        self.output_dir = 'save_models/'

        # if args.report_path:
        #     self.report_path = args.report_path
        #
        # if args.embedding:
        #     self.embedding = args.embedding
        #
        # if args.classifier:
        #     self.classifier_name = args.classifier
        logger.info('Predictor initialized with args')
        self.print_args()

    def print_args(self):
        logger.info(' ----------------------------')
        logger.info('| report path: ' + self.report_path)
        logger.info('| embedding: ' + self.embedding)
        logger.info('| classifier: ' + self.classifier_name)
        logger.info(' ----------------------------')

    def tfidf(self, report):
        tfidf_conf = Config({
            'do_training': False,
            'model_name': 'tfidf_range_1_3_kbest_10000',
            'output_dir': self.output_dir
        })
        tfidf_model = TfidfModel(tfidf_conf)
        vectors = tfidf_model.transform([report])

        if self.classifier_name == 'svc':
            svc_conf = Config({
                'do_training': False,
                'model_name': 'svc_tfidf',
                'output_dir': self.output_dir
            })
            model = SVCModel(svc_conf)
            prediction = Predictor.classify(model, vectors)

        elif self.classifier_name == 'xgboost':
            xgb_conf = Config({
                "do_training": False,
                'model_name': 'xgb_tfidf',
                'n_estimators': [80],
                'output_dir': self.output_dir
            })
            model = XGBoostModel(xgb_conf)
            prediction = Predictor.classify(model, vectors)

        return prediction

    def doc2vec(self, report):
        dm_model_path = self.output_dir + 'model.1.d2v'
        dbow_model_path = self.output_dir + 'model.0.d2v'
        combination = Doc2VecCombinator(
            dm_model_path,
            dbow_model_path
        )
        vectors = combination.infer_vectors([report])

        if self.classifier_name == 'svc':
            svc_conf = Config({
                'do_training': False,
                'model_name': 'svc_d2v_concat',
                'output_dir': self.output_dir
            })
            model = SVCModel(svc_conf)
            prediction = self.classify(model, vectors)

        elif self.classifier_name == 'xgboost':
            xgb_conf = Config({
                "do_training": False,
                'model_name': 'xgb_d2v_concat',
                'n_estimators': [80],
                'output_dir': self.output_dir
            })
            model = XGBoostModel(xgb_conf)
            prediction = self.classify(model, vectors)

        return prediction

    def transformer(self, report):
        # TODO dopsat vsechny modely
        model_name = 'bert'
        if self.embedding == 'roberta':
            model_name = 'roberta_2000_batch8_lr1e-5'
        elif self.embedding == 'bert':
            model_name = 'bert...'
        elif self.embedding == 'distilbert':
            model_name = 'distilbert_2000_batch8_lr2e-5'

        conf = Config({
            'do_training': False,
            'model': self.embedding,
            'model_name': model_name,
            'output_dir': self.output_dir,
            'chunk_size': 500,
            'stride': 0
        })
        model = TransformerModel(conf)
        prediction = model.predict_report(report)
        return prediction

    @staticmethod
    def classify(model, vectors):
        prediction = model.predict(vectors, 'report')[0]
        return prediction

    def detect_report(self):
        to_string = True if self.embedding == 'tfidf' or self.embedding == 'doc2vec' else False
        report = load_report(self.report_path)
        report = clean_report(report)

        if to_string:
            report = convert_to_string(report)

        pred = None
        if self.embedding == 'tfidf':
            pred = self.tfidf(report)

        elif self.embedding == 'doc2vec':
            pred = self.doc2vec(report)


        elif self.embedding == 'bert' or self.embedding == 'albert' or self.embedding == 'roberta' or self.embedding == 'distilbert' or self.embedding == 'flaubert':
            pred = self.transformer(report)

        if pred == 1 or pred == 0:
            mark = 'MALWARE' if pred == 1 else 'BENINGWARE'
            logger.info('Application classified as ' + mark)

        else:
            logger.info('Error occurred during classification')


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Detect malware in behavioural report')
    parser.add_argument("-R", "--report_path", help="path to behavioural report")
    parser.add_argument("-E", "--embedding", help="which embedding method to use -> tfidf | doc2vec | bert")
    parser.add_argument("-C", "--classifier",
                        help="which classifier to use for TF-IDF or Doc2Vec embedding -> svc | xgboost")

    args = parser.parse_args()

    predictor = Predictor()
    predictor.detect_report()
