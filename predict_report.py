from config.config import Config
from helpers.utils import load_report, clean_report, convert_to_string, print_args
from embeddings.TransformerModel import TransformerModel
from classifiers.SVC import SVCModel
from classifiers.XGBoost import XGBoostModel
from embeddings.TfidfModel import TfidfModel
from embeddings.Doc2VecCombinator import Doc2VecCombinator
import argparse
import os
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

"""
Script for running classification on a single behavioural report
"""

class Predictor:
    def __init__(self):
        # ---> !SPECIFY MODEL NAMES!
        self.tfidf_model_name = 'tfidf_range_1_2_kbest_10000'

        self.d2v_dm_model_name = 'd2v_dm_model'
        self.d2v_dbow_model_name = 'd2v_dbow_model'
        self.d2v_concat_model_name = 'd2v_concat'

        self.bert_model_name = 'bert_3000_batch8_lr1e-5_4'
        self.roberta_model_name = 'roberta_2000_batch8_lr1e-5'
        self.distilbert_model_name = 'distilbert_2000_batch8_lr2e-5'
        # <---

        self.output_dir = 'saved_models'

        # ---> Init params, overwritten by Command Line Args
        self.report_path = 'report_samples/report_malware.json'
        self.embedding = 'doc2vec'
        self.classifier = 'svc'
        # <---

        if args.report_path:
            self.report_path = args.report_path

        if args.embedding:
            self.embedding = args.embedding

        if args.classifier:
            self.classifier = args.classifier
        logger.info('Predictor initialized with args')
        print_args(self.__dict__)

    def tfidf(self, report):
        """
        Run TF-IDF embedding and then classification on outputted vector
        :param report: behavioral report
        :return prediction
        """

        # initialize TF-IDF model
        tfidf_conf = Config({
            'do_training': False,
            'model_name': self.tfidf_model_name,
            'output_dir': self.output_dir
        })
        tfidf_model = TfidfModel(tfidf_conf)

        # embedding
        vectors = tfidf_model.transform([report])

        # classification
        if self.classifier == 'svc':
            svc_conf = Config({
                'do_training': False,
                'model_name': tfidf_conf.get('model_name'),
                'output_dir': self.output_dir
            })
            model = SVCModel(svc_conf)
            prediction = Predictor.classify(model, vectors)

        elif self.classifier == 'xgboost':
            xgb_conf = Config({
                "do_training": False,
                'model_name': tfidf_conf.get('model_name'),
                'n_estimators': [80],
                'output_dir': self.output_dir
            })
            model = XGBoostModel(xgb_conf)
            prediction = Predictor.classify(model, vectors)

        return prediction

    def doc2vec(self, report):
        """
        Run Paragraph Vector (Doc2Vec) embedding and then classification on outputted vector
        :param report: behavioral report
        :return: prediction
        """

        dm_model_path = os.path.join(self.output_dir, self.d2v_dm_model_name, self.d2v_dm_model_name + '.d2v')
        dbow_model_path = os.path.join(self.output_dir, self.d2v_dbow_model_name, self.d2v_dbow_model_name + '.d2v')

        # initialize concatenated model
        combination = Doc2VecCombinator(
            dm_model_path,

            dbow_model_path
        )

        # embedding
        vectors = combination.infer_vectors([report])

        # classification
        if self.classifier == 'svc':
            svc_conf = Config({
                'do_training': False,
                'model_name': self.d2v_concat_model_name,
                'output_dir': self.output_dir
            })
            model = SVCModel(svc_conf)
            prediction = self.classify(model, vectors)

        elif self.classifier == 'xgboost':
            xgb_conf = Config({
                "do_training": False,
                'model_name': self.d2v_concat_model_name,
                'n_estimators': [80],
                'output_dir': self.output_dir
            })
            model = XGBoostModel(xgb_conf)
            prediction = self.classify(model, vectors)

        return prediction

    def transformer(self, report):
        """
        Run Transformer model classification
        :param report: behavioral report
        :return: prediction
        """
        if self.embedding == 'roberta':
            model_name = self.roberta_model_name
        elif self.embedding == 'bert':
            model_name = self.bert_model_name
        elif self.embedding == 'distilbert':
            model_name = self.distilbert_model_name

        # model initializing
        conf = Config({
            'do_training': False,
            'model': self.embedding,
            'model_name': model_name,
            'output_dir': self.output_dir,
            'chunk_size': 500,
            'stride': 0
        })
        model = TransformerModel(conf)

        # classification
        prediction = model.predict_report(report, pooling_strategy='mean')
        return prediction

    @staticmethod
    def classify(model, vectors):
        prediction = model.predict(vectors, 'report')[0]
        return prediction

    def detect_report(self):
        """
        Run classification of behavioral report based on config and print results
        """

        # mark whether to keep the attributes in reports or return report content as a one big string
        to_string = True if self.embedding == 'tfidf' or self.embedding == 'doc2vec' else False

        # prepare report
        report = load_report(self.report_path)
        report = clean_report(report)

        if to_string:
            report = convert_to_string(report)

        pred = None
        if self.embedding == 'tfidf':
            pred = self.tfidf(report)

        elif self.embedding == 'doc2vec':
            pred = self.doc2vec(report)

        elif self.embedding == 'bert'\
                or self.embedding == 'albert'\
                or self.embedding == 'roberta'\
                or self.embedding == 'distilbert'\
                or self.embedding == 'flaubert':
            pred = self.transformer(report)

        if pred == 1 or pred == 0:

            if pred == 1:
                logger.info(' --------------------------------------------')
                logger.info('| WARNING! Application classified as MALWARE |')
                logger.info(' --------------------------------------------')
            else:
                logger.info(' ----------------------------------')
                logger.info('| Keep calm. Application is BENIGN |')
                logger.info(' ----------------------------------')

        else:
            logger.info('Error occurred during classification')

        logger.info('Task completed')


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Detect malware in behavioural report')
    parser.add_argument("-R", "--report_path", help="path to behavioural report")
    parser.add_argument("-E", "--embedding", help="which embedding method to use -> tfidf | doc2vec | bert")
    parser.add_argument("-C", "--classifier",
                        help="which classifier to use for TF-IDF or Doc2Vec embedding -> svc | xgboost")

    args = parser.parse_args()

    predictor = Predictor()
    predictor.detect_report()
